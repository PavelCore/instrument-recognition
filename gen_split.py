import multi_label_stratif
import numpy as np
import pandas as pd
import cPickle
import sys
import os
from scipy.io import (savemat, loadmat)


def read_grouping(groupID, fpath=os.curdir):
    """read grouping
    Args:
        groupID (int): the ID number for grouping to use
    Returns:
        grouping (dict): map from original instrument to corresponding group
    """
    instGrouping = pd.read_csv('./instGroup.csv')
    grouping = dict(zip(instGrouping['Instrument'].values,
                        instGrouping['Group {}'.format(groupID)].values))
    return grouping


def read_song_instr_map(fpath=os.curdir):
    """read song instrument mapping
    """
    with open(os.path.join(fpath, 'song_instr.pkl'), 'rb') as f:
        label_mapping = cPickle.load(f)
    return label_mapping


def read_song_list(fpath=os.curdir):
    """read song name list generated by data_prep.py
    """
    with open(os.path.join(fpath, 'song_name_list.txt'), 'rb') as f:
        song_name_list = f.read().strip().split('\n')
    return song_name_list


def read_instr_list(fpath=os.curdir):
    """read instrument list generated by data_prep.py
    """
    with open(os.path.join('all_instruments.txt'), 'rb') as f:
        all_instruments = f.read().strip().split('\n')
    return all_instruments


def replace_with_grouping(label_mapping, grouping):
    for k, v in label_mapping.items():
        label_mapping[k] = set([grouping[i] for i in v])
    return label_mapping


def get_rare_instr(label_mapping, all_instruments, thres):
    """get a set of rare instruments
    Args:
        label_mapping (dict):
        all_instruments (list):
        thres (int): the number of appearance before which is considered rare
    Returns:
        rare_instr (set): set of rare instruments
    """
    cnt = {i: 0 for i in all_instruments}
    for k, v in label_mapping.items():
        for i in v:
            cnt[i] = cnt.get(i, 0) + 1
    rare_instr = set()
    for k, v in cnt.items():
        if v < thres:
            rare_instr.add(k)
    return rare_instr


def replace_rare(label_mapping, rare_instr):
    """raplace rare instruments with 'OTHER'
    """
    for k, v in label_mapping.items():
        label_mapping[k] = v - rare_instr
        if label_mapping[k] < len(v):
            print '{} has rare item'.format(k)
            label_mapping[k] = label_mapping[k].add('OTHER')


def do_split(X, label_mapping, kwargs):
    """Do the split with multi_label_stratif.py
    Args:
        X (list): list of song names
        label_mapping (dict):
        kwargs (dict): arguments to pass to multi_label_stratif
    Returns:
        train (list): list of song names in training set
        test (list): list of song names in test set
    """
    y = [list(label_mapping[i]) for i in X]
    train_i, test_i = multi_label_stratif.multi_label_stratif(y, **kwargs)
    X = np.array(X, dtype=object)
    train = X[train_i]
    test = X[test_i]
    with open('train_songs.txt', 'wb') as f:
        f.write('\n'.join(train))
    with open('test_songs.txt', 'wb') as f:
        f.write('\n'.join(test))
    return train, test


def build_train_test_set(train, test, all_instruments, rare_instr):
    """Build training and test set files from data file for individual songs
    Args:
        train (list): as returned from do_split
        test (list): as returned from do_split
    """
    # get indices for rare instruments
    rare_index = [i for i, e in enumerate(all_instruments) if e in rare_instr]
    nonrare_index = [i for i, e in enumerate(all_instruments)
                     if e not in rare_instr]
    print 'Number of nonrare instruments = {}'.format(len(nonrare_index))

    # initialize
    train_data = [[], [], [], [], []]
    test_data = [[], [], [], [], []]

    # build test set
    for i in test:
        data = loadmat(os.path.join('data', '{}_patched.mat'.format(i)))
        for j, e in enumerate(['X', 'y', 'present', 'song_name', 'time']):
            test_data[j].append(data[e])
        del data
    test_data = [np.vstack(i) for i in test_data]
    test_data = dict(zip(['test_X', 'test_y', 'test_p', 'test_s', 'test_t'],
                         test_data))
    # deal with OTHER instruments
    temp = test_data['test_y'][:, nonrare_index]
    test_data['test_y'] = np.hstack([temp, test_data['test_y'][:, rare_index].
                                     max(1).reshape(len(temp), 1)])
    test_data['test_p'] = np.hstack([test_data['test_p'][:, nonrare_index],
                                     np.zeros((len(temp), 1),
                                              dtype='float32')])
    print 'test set shape: {}'.format(test_data['test_y'].shape)
    savemat(os.path.join('data', 'test.mat'), test_data)
    del test_data
    print 'finished building test set'

    # build training set
    for i in train:
        data = loadmat(os.path.join('data', '{}_patched.mat'.format(i)))
        for j, e in enumerate(['X', 'y', 'present', 'song_name', 'time']):
            train_data[j].append(data[e])
        del data
    train_data = [np.vstack(i) for i in train_data]
    train_data = dict(zip(['train_X', 'train_y', 'train_p', 'train_s',
                           'train_t'], train_data))
    # deal with OTHER instruments
    temp = train_data['train_y'][:, nonrare_index]
    train_data['train_y'] = np.hstack([temp,
                                       train_data['train_y'][:, rare_index].
                                       max(1).reshape(len(temp), 1)])
    train_data['train_p'] = np.hstack([train_data['train_p'][:, nonrare_index],
                                       np.zeros((len(temp), 1),
                                                dtype='float32')])
    print 'training set shape'.format(train_data['train_y'].shape)
    savemat(os.path.join('data', 'train.mat'), train_data)
    del train_data
    print 'finished building training set'


def generate_split(groupID, rare_thres, songs_to_split=None, start_song=0,
                   end_song=122, fpath=os.curdir,
                   kwargs_split={'num_split': 2, 'p_split': [0.6, 0.4],
                                 'rand_state': 2345}):
    """Do this split
    Args:
        groupID (int): group ID to use for grouping
        rare_thres (int): threshold below which is considered rare instrument
        songs_to_split (list): list of int, indexing song names in
                               song_name_list.txt generated by data_prep.py.
                               Must be None if start_song and end_song is used.
        start_song (int): The starting index for a contiguous subsequence of
                          song_name_list to use for split.
        end_song (int): The ending index for a contiguous subsequence of
                        song_name_list to use for split.
        fpath (str): the data path to operate on
    """
    grouping = read_grouping(groupID, fpath)
    label_mapping = read_song_instr_map(fpath)
    song_name_list = read_song_list(fpath)
    all_instruments = read_instr_list(fpath)
    if songs_to_split is None:
        song_name_list = [song_name_list[i] for i in songs_to_split]
    else:
        song_name_list = song_name_list[start_song:end_song]

    # get label mapping for songs considered only
    label_mapping = {i: label_mapping[i] for i in song_name_list}

    label_mapping = replace_with_grouping(label_mapping, grouping)
    rare_instr = get_rare_instr(label_mapping, all_instruments, rare_thres)
    replace_rare(label_mapping, rare_instr)
    train, test = do_split(song_name_list, label_mapping, kwargs_split)
    with open('train_songs.txt', 'wb') as f:
        f.write('\n'.join(train))
    with open('test_songs.txt', 'wb') as f:
        f.write('\n'.join(test))
    build_train_test_set(train, test, all_instruments, rare_instr)


def main():
    generate_split(4, 4)
